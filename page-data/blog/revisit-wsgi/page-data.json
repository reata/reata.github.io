{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-js","path":"/blog/revisit-wsgi/","result":{"data":{"markdownRemark":{"html":"<p>写过Python Web应用，尤其进行过线上部署的人，一定都听说过WSGI这个协议。它定义了Python的Web服务器和Web应用之间的数据交换接口。这个说法本身是比较抽象的，我们用实际的例子来解释一下可能会更清楚一些：</p>\n<p>试想我们用Django或者Flask等Web应用框架写了一个Web应用，官方文档里都会提到，框架自带的server，像Django的<code>python manage runserver</code>或者Flask的<code>flask --app hello run</code>，仅供开发阶段调试，不足以处理生产环境的流量。在部署到生产时，都需要将Web应用放在Web服务器后面运行，典型的Web服务器有Gunicorn和uWSGI。Web服务器会提供诸如进程模型、线程模型等并发选项，来提升Web应用的并发性能。</p>\n<p>针对上面这个简单的情景，就有四种技术选型组合：Gunicorn + Django, Gunicorn + Flask, uWSGI + Django, uWSGI + Flask。不同的组合，如果要Web应用框架提供不同的Web服务适配代码，N**2的复杂度，显然是不合算的。WSGI存在的目的，就是定义好了Web服务器和Web应用之间的接口。框架的开发者都针对这个接口来编码即可。而对于Web应用的开发，就拥有了更多选型的自由，同样的Django代码，我既可以选择让它跑在Gunicorn上，也可以跑在uWSGI上。</p>\n<h2>抛开Web应用框架</h2>\n<p>在我们讨论Django和Flask针对WSGI的适配之前，让我们再将问题简化一些。Web框架存在的原因是什么？是提供一些便利的功能，比如路由，比如HTTP请求解析，帮助我们更容易更快地写出Web应用对吧。那么其实针对非常简单的应用，我们也是可以不用框架来写的。</p>\n<p>PEP定义的WSGI接口非常简单，没有（也不应该）用到任何Web框架：</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">HELLO_WORLD <span class=\"token operator\">=</span> <span class=\"token string\">b\"Hello world!\\n\"</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">simple_app</span><span class=\"token punctuation\">(</span>environ<span class=\"token punctuation\">,</span> start_response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token triple-quoted-string string\">\"\"\"Simplest possible application object\"\"\"</span>\n    status <span class=\"token operator\">=</span> <span class=\"token string\">'200 OK'</span>\n    response_headers <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Content-type'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'text/plain'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    start_response<span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">,</span> response_headers<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>HELLO_WORLD<span class=\"token punctuation\">]</span></code></pre></div>\n<p>这样一个简单的Web应用，和Web服务器之间，就通过environ环境变量字典和start_response函数来交互。Web服务器会保证传入正确的参数。</p>\n<p>假定我们将上面的代码保存在app.py中，并且已经安装好了Gunicorn，那么我们就可以用如下命令来启动这个应用</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">gunicorn app:simple_app</code></pre></div>\n<p>默认Gunicorn会绑定8000端口，我们用curl发送一个请求试试</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">curl</span> http://localhost:8000\nHello world<span class=\"token operator\">!</span></code></pre></div>\n<p>一切如我们所料。同时，注意到我们这个Web应用的代码逻辑是非常简单的，不考虑请求的路径（\"/\"，\"/api\"，etc.），请求的方法（GET，POST，PUT，etc.），应用始终返回200的状态码以及Hello World!作为响应的body。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ curl http://localhost:8080/non-exist-endpoint\nHello world!\n$ curl -X POST http://localhost:8080\nHello world!</code></pre></div>\n<h2>超越Hello World</h2>\n<p>正如上面所述，一个正常的Web应用，肯定会有不止一个endpoint。我们也会希望根据请求的不同，来返回不同的响应。</p>\n<p>而请求所有的信息，Web服务器都会放在environ这个字典当中，同时还会包含其它的环境变量。</p>\n<p>在所有的key当中，我们最需要关注的，有下面三个：</p>\n<ol>\n<li>REQUEST_METHOD：即请求方法，GET/POST等。</li>\n<li>PATH_INFO：即请求路径。</li>\n<li>wsgi.input：是一个文件对象，当请求body中包含数据时，我们可以通过这个对象来读取。另一个key，CONTENT_LENGTH会指明请求body的长度。二者通常配合使用。</li>\n</ol>\n<p>假定这里我们要在/路径上，实现一个新的POST接口，接收JSON类型的参数，用户传入{\"name\": \"xxx\"}，Web应用会返回Hello, xxx! GET接口不变，继续返回Hello, World!</p>\n<p>代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> json\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">simple_app</span><span class=\"token punctuation\">(</span>environ<span class=\"token punctuation\">,</span> start_response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    request_method <span class=\"token operator\">=</span> environ<span class=\"token punctuation\">[</span><span class=\"token string\">\"REQUEST_METHOD\"</span><span class=\"token punctuation\">]</span>\n    path_info <span class=\"token operator\">=</span> environ<span class=\"token punctuation\">[</span><span class=\"token string\">\"PATH_INFO\"</span><span class=\"token punctuation\">]</span>\n    response_headers <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Content-type'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'text/plain'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">if</span> path_info <span class=\"token operator\">==</span> <span class=\"token string\">'/'</span><span class=\"token punctuation\">:</span>\n        status <span class=\"token operator\">=</span> <span class=\"token string\">'200 OK'</span>\n        <span class=\"token keyword\">if</span> request_method <span class=\"token operator\">==</span> <span class=\"token string\">'GET'</span><span class=\"token punctuation\">:</span>\n            body <span class=\"token operator\">=</span> <span class=\"token string\">b'Hello world!\\n'</span>\n        <span class=\"token keyword\">elif</span> request_method <span class=\"token operator\">==</span> <span class=\"token string\">'POST'</span><span class=\"token punctuation\">:</span>\n            request_body_size <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>environ<span class=\"token punctuation\">[</span><span class=\"token string\">\"CONTENT_LENGTH\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            request_body <span class=\"token operator\">=</span> environ<span class=\"token punctuation\">[</span><span class=\"token string\">\"wsgi.input\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>read<span class=\"token punctuation\">(</span>request_body_size<span class=\"token punctuation\">)</span>\n            payload <span class=\"token operator\">=</span> json<span class=\"token punctuation\">.</span>loads<span class=\"token punctuation\">(</span>request_body<span class=\"token punctuation\">)</span>\n            name <span class=\"token operator\">=</span> payload<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span>\n            body <span class=\"token operator\">=</span> <span class=\"token string-interpolation\"><span class=\"token string\">f\"Hello </span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">}</span></span><span class=\"token string\">!\\n\"</span></span><span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token string\">\"utf-8\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            status <span class=\"token operator\">=</span> <span class=\"token string\">'405 Method Not Allowed'</span>\n            body <span class=\"token operator\">=</span> <span class=\"token string\">b'Method Not Allowed!\\n'</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        status <span class=\"token operator\">=</span> <span class=\"token string\">'404 NOT FOUND'</span>\n        body <span class=\"token operator\">=</span> <span class=\"token string\">b'Not Found!\\n'</span>\n    start_response<span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">,</span> response_headers<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>body<span class=\"token punctuation\">]</span></code></pre></div>\n<p>这里除去请求路径和请求方法的处理之外，我们还加了一些简单的客户端错误检测，比如访问/之外的路径，会返回404。用非GET或者POST的方法访问/，会返回405。</p>\n<p>简单测试如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">curl</span> http://localhost:8080/\nHello World<span class=\"token operator\">!</span>\n$ <span class=\"token function\">curl</span> <span class=\"token parameter variable\">-X</span> POST http://localhost:8080/ <span class=\"token parameter variable\">-d</span> <span class=\"token string\">'{\"name\": \"reata\"}'</span>\nHello reata<span class=\"token operator\">!</span>\n$ <span class=\"token function\">curl</span> <span class=\"token parameter variable\">-X</span> PUT http://localhost:8080/                  \nMethod Not Allowed<span class=\"token operator\">!</span>\n$ <span class=\"token function\">curl</span> http://localhost:8080/non-exist-path\nNot Found<span class=\"token operator\">!</span></code></pre></div>\n<h2>变得更像Flask</h2>\n<p>不难想象，随着我们Web应用的逻辑越来越复杂，simple_app这个函数会越来越冗长。意大利面式的代码显然不是良好的编程实践。</p>\n<p>我们可以参照Flask的API，来做一些简单的封装。</p>\n<p>比如将函数切换成class的callable，让Web应用的开发者可以拿到WSGI的app；内部用routes来保存所有path->handler的映射；将environ封装成一个request对象等。</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyWebFramework</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>routes <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">def</span> <span class=\"token function\">route</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    \t<span class=\"token keyword\">def</span> <span class=\"token function\">wrapper</span><span class=\"token punctuation\">(</span>handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            self<span class=\"token punctuation\">.</span>routes<span class=\"token punctuation\">[</span>path<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> handler\n            <span class=\"token keyword\">return</span> handler\n\n        <span class=\"token keyword\">return</span> wrapper\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__call__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> environ<span class=\"token punctuation\">,</span> start_response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        request <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>assemble_request<span class=\"token punctuation\">(</span>environ<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> path_info <span class=\"token keyword\">in</span> self<span class=\"token punctuation\">.</span>routes<span class=\"token punctuation\">:</span>\n            handler <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>routes<span class=\"token punctuation\">[</span>path_info<span class=\"token punctuation\">]</span>\n            <span class=\"token keyword\">return</span> handler<span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># return 404</span>\n\napp <span class=\"token operator\">=</span> MyWebFramework<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token decorator annotation punctuation\">@app<span class=\"token punctuation\">.</span>route</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/my_endpoint\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">my_endpoint_handler</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># business logic here to handle request and assemble response</span>\n    <span class=\"token keyword\">return</span> response</code></pre></div>\n<p>这样，MyWebFramework的部分就可以逐渐抽象出一个Web应用框架，而真正开发Web应用的业务逻辑，只要写各个handler即可。</p>\n<p>参考<a href=\"https://github.com/pallets/flask/blob/2.2.2/src/flask/app.py#L2495\">flask.app.Flask</a>的源码，它也是这么写的。Flask应用源自Flask这个核心类，它本身同时就是一个WSGI应用。</p>\n<p>Django的设计上稍稍有一些不同，它自己提出并实现了一个ASGI(Asynchronous Server Gateway Interface)的协议，来支持异步请求。一个Django应用可以通过内部函数，转换成ASGI应用或WSGI应用。当我们只关心<a href=\"https://github.com/django/django/blob/4.1.2/django/core/handlers/wsgi.py#L127\">WSGI的部分</a>，会发现一切都还是非常熟悉的内容。</p>\n<h2>SQLLineage的例子</h2>\n<p><a href=\"https://github.com/reata/sqllineage/blob/master/sqllineage/drawing.py\">sqllineage</a>就是用这个思路实现了一个兼容WSGI的Web应用。起因是有用户反馈，他们用不到可视化这部分的功能，希望剥离flask相关的依赖。</p>\n<p>sqllineage是一个SQL数据血缘分析工具，用flask来启动可视化Web应用确实有些重了。于是索性就自己参照Flask实现了一个。</p>\n<p>其中我只针对POST相关的接口做了路由，也没有将environ变量封装成request对象。而默认的web服务器，用了标准库自带的wsgiref。这样全程在不引入第三方依赖的情况下，还是达到了和使用flask相同的效果。</p>\n<h2>Java的术语</h2>\n<p>其实WSGI这件事用Java的概念是非常好解释的，<a href=\"https://peps.python.org/pep-3333/\">PEP 3333</a>本身也提到了这点。</p>\n<p>在Java生态中，WSGI就相当于servlet API。一个Java Web应用，只要实现了servlet接口，打成war包（Java Web Application Archive），就可以交给不同的Web服务器来运行。常见的开源Java Web服务器包括Tomcat，Jetty，商用的如Oracle的WebLogic，IBM的WebSphere。Web服务器自身会启动Java虚拟机，然后加载war文件。</p>\n<p>当然事实上我们不会自己去实现servlet接口来写Web应用，都是直接用Spring Boot了。近些年随着Spring Boot以及docker的流行，war包的部署形式已经不再常用。但背后的概念是没有变的，<code>spring-boot-starter-web</code>只是默认帮你捆绑好了Tomcat，并打成Jar包。servlet的概念不再强调，但依然是存在于应用之中的。</p>\n<h2>参考阅读</h2>\n<ol>\n<li><a href=\"https://peps.python.org/pep-0333/\">PEP 333 – Python Web Server Gateway Interface v1.0</a></li>\n<li><a href=\"https://peps.python.org/pep-3333/\">PEP 3333 – Python Web Server Gateway Interface v1.0.1</a></li>\n<li><a href=\"https://testdriven.io/courses/python-web-framework/\">Building Your Own Python Web Framework</a></li>\n</ol>","rawMarkdownBody":"\n写过Python Web应用，尤其进行过线上部署的人，一定都听说过WSGI这个协议。它定义了Python的Web服务器和Web应用之间的数据交换接口。这个说法本身是比较抽象的，我们用实际的例子来解释一下可能会更清楚一些：\n\n试想我们用Django或者Flask等Web应用框架写了一个Web应用，官方文档里都会提到，框架自带的server，像Django的`python manage runserver`或者Flask的`flask --app hello run`，仅供开发阶段调试，不足以处理生产环境的流量。在部署到生产时，都需要将Web应用放在Web服务器后面运行，典型的Web服务器有Gunicorn和uWSGI。Web服务器会提供诸如进程模型、线程模型等并发选项，来提升Web应用的并发性能。\n\n针对上面这个简单的情景，就有四种技术选型组合：Gunicorn + Django, Gunicorn + Flask, uWSGI + Django, uWSGI + Flask。不同的组合，如果要Web应用框架提供不同的Web服务适配代码，N**2的复杂度，显然是不合算的。WSGI存在的目的，就是定义好了Web服务器和Web应用之间的接口。框架的开发者都针对这个接口来编码即可。而对于Web应用的开发，就拥有了更多选型的自由，同样的Django代码，我既可以选择让它跑在Gunicorn上，也可以跑在uWSGI上。\n\n## 抛开Web应用框架\n\n在我们讨论Django和Flask针对WSGI的适配之前，让我们再将问题简化一些。Web框架存在的原因是什么？是提供一些便利的功能，比如路由，比如HTTP请求解析，帮助我们更容易更快地写出Web应用对吧。那么其实针对非常简单的应用，我们也是可以不用框架来写的。\n\nPEP定义的WSGI接口非常简单，没有（也不应该）用到任何Web框架：\n```python\nHELLO_WORLD = b\"Hello world!\\n\"\n\ndef simple_app(environ, start_response):\n    \"\"\"Simplest possible application object\"\"\"\n    status = '200 OK'\n    response_headers = [('Content-type', 'text/plain')]\n    start_response(status, response_headers)\n    return [HELLO_WORLD]\n```\n\n这样一个简单的Web应用，和Web服务器之间，就通过environ环境变量字典和start_response函数来交互。Web服务器会保证传入正确的参数。\n\n假定我们将上面的代码保存在app.py中，并且已经安装好了Gunicorn，那么我们就可以用如下命令来启动这个应用\n```bash\ngunicorn app:simple_app\n```\n\n默认Gunicorn会绑定8000端口，我们用curl发送一个请求试试\n```bash\n$ curl http://localhost:8000\nHello world!\n```\n\n一切如我们所料。同时，注意到我们这个Web应用的代码逻辑是非常简单的，不考虑请求的路径（\"/\"，\"/api\"，etc.），请求的方法（GET，POST，PUT，etc.），应用始终返回200的状态码以及Hello World!作为响应的body。\n\n```\n$ curl http://localhost:8080/non-exist-endpoint\nHello world!\n$ curl -X POST http://localhost:8080\nHello world!\n```\n\n## 超越Hello World\n\n正如上面所述，一个正常的Web应用，肯定会有不止一个endpoint。我们也会希望根据请求的不同，来返回不同的响应。\n\n而请求所有的信息，Web服务器都会放在environ这个字典当中，同时还会包含其它的环境变量。\n\n在所有的key当中，我们最需要关注的，有下面三个：\n\n1. REQUEST_METHOD：即请求方法，GET/POST等。\n2. PATH_INFO：即请求路径。\n3. wsgi.input：是一个文件对象，当请求body中包含数据时，我们可以通过这个对象来读取。另一个key，CONTENT_LENGTH会指明请求body的长度。二者通常配合使用。\n\n假定这里我们要在/路径上，实现一个新的POST接口，接收JSON类型的参数，用户传入{\"name\": \"xxx\"}，Web应用会返回Hello, xxx! GET接口不变，继续返回Hello, World!\n\n代码如下：\n```python\nimport json\n\ndef simple_app(environ, start_response):\n    request_method = environ[\"REQUEST_METHOD\"]\n    path_info = environ[\"PATH_INFO\"]\n    response_headers = [('Content-type', 'text/plain')]\n    if path_info == '/':\n        status = '200 OK'\n        if request_method == 'GET':\n            body = b'Hello world!\\n'\n        elif request_method == 'POST':\n            request_body_size = int(environ[\"CONTENT_LENGTH\"])\n            request_body = environ[\"wsgi.input\"].read(request_body_size)\n            payload = json.loads(request_body)\n            name = payload.get(\"name\", \"\")\n            body = f\"Hello {name}!\\n\".encode(\"utf-8\")\n        else:\n            status = '405 Method Not Allowed'\n            body = b'Method Not Allowed!\\n'\n    else:\n        status = '404 NOT FOUND'\n        body = b'Not Found!\\n'\n    start_response(status, response_headers)\n    return [body]\n```\n\n这里除去请求路径和请求方法的处理之外，我们还加了一些简单的客户端错误检测，比如访问/之外的路径，会返回404。用非GET或者POST的方法访问/，会返回405。\n\n简单测试如下：\n\n```bash\n$ curl http://localhost:8080/\nHello World!\n$ curl -X POST http://localhost:8080/ -d '{\"name\": \"reata\"}'\nHello reata!\n$ curl -X PUT http://localhost:8080/                  \nMethod Not Allowed!\n$ curl http://localhost:8080/non-exist-path\nNot Found!\n```\n\n\n## 变得更像Flask\n\n不难想象，随着我们Web应用的逻辑越来越复杂，simple_app这个函数会越来越冗长。意大利面式的代码显然不是良好的编程实践。\n\n我们可以参照Flask的API，来做一些简单的封装。\n\n比如将函数切换成class的callable，让Web应用的开发者可以拿到WSGI的app；内部用routes来保存所有path->handler的映射；将environ封装成一个request对象等。\n```python\nclass MyWebFramework:\n    def __init__(self):\n        self.routes = {}\n    \n    def route(self, path):\n    \tdef wrapper(handler):\n            self.routes[path] = handler\n            return handler\n\n        return wrapper\n\n    def __call__(self, environ, start_response):\n        request = self.assemble_request(environ)\n        if path_info in self.routes:\n            handler = self.routes[path_info]\n            return handler(request)\n        else:\n            # return 404\n\napp = MyWebFramework()\n\n@app.route(\"/my_endpoint\")\ndef my_endpoint_handler(request):\n    # business logic here to handle request and assemble response\n    return response\n```\n\n这样，MyWebFramework的部分就可以逐渐抽象出一个Web应用框架，而真正开发Web应用的业务逻辑，只要写各个handler即可。\n\n参考[flask.app.Flask](https://github.com/pallets/flask/blob/2.2.2/src/flask/app.py#L2495)的源码，它也是这么写的。Flask应用源自Flask这个核心类，它本身同时就是一个WSGI应用。\n\nDjango的设计上稍稍有一些不同，它自己提出并实现了一个ASGI(Asynchronous Server Gateway Interface)的协议，来支持异步请求。一个Django应用可以通过内部函数，转换成ASGI应用或WSGI应用。当我们只关心[WSGI的部分](https://github.com/django/django/blob/4.1.2/django/core/handlers/wsgi.py#L127)，会发现一切都还是非常熟悉的内容。\n\n## SQLLineage的例子\n\n[sqllineage](https://github.com/reata/sqllineage/blob/master/sqllineage/drawing.py)就是用这个思路实现了一个兼容WSGI的Web应用。起因是有用户反馈，他们用不到可视化这部分的功能，希望剥离flask相关的依赖。\n\nsqllineage是一个SQL数据血缘分析工具，用flask来启动可视化Web应用确实有些重了。于是索性就自己参照Flask实现了一个。\n\n其中我只针对POST相关的接口做了路由，也没有将environ变量封装成request对象。而默认的web服务器，用了标准库自带的wsgiref。这样全程在不引入第三方依赖的情况下，还是达到了和使用flask相同的效果。\n\n## Java的术语\n\n其实WSGI这件事用Java的概念是非常好解释的，[PEP 3333](https://peps.python.org/pep-3333/)本身也提到了这点。\n\n在Java生态中，WSGI就相当于servlet API。一个Java Web应用，只要实现了servlet接口，打成war包（Java Web Application Archive），就可以交给不同的Web服务器来运行。常见的开源Java Web服务器包括Tomcat，Jetty，商用的如Oracle的WebLogic，IBM的WebSphere。Web服务器自身会启动Java虚拟机，然后加载war文件。\n\n当然事实上我们不会自己去实现servlet接口来写Web应用，都是直接用Spring Boot了。近些年随着Spring Boot以及docker的流行，war包的部署形式已经不再常用。但背后的概念是没有变的，`spring-boot-starter-web`只是默认帮你捆绑好了Tomcat，并打成Jar包。servlet的概念不再强调，但依然是存在于应用之中的。\n\n## 参考阅读\n1. [PEP 333 – Python Web Server Gateway Interface v1.0](https://peps.python.org/pep-0333/)\n2. [PEP 3333 – Python Web Server Gateway Interface v1.0.1](https://peps.python.org/pep-3333/)\n3. [Building Your Own Python Web Framework](https://testdriven.io/courses/python-web-framework/)\n","frontmatter":{"date":"October 30, 2022","slug":"/blog/revisit-wsgi/","title":"再探WSGI","excerpt":"不用框架，写一个兼容WSGI的Python Web应用","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/3abd686ff30f995d2fd0b685ff9d7ec1/3befa/wsgi.png","srcSet":"/static/3abd686ff30f995d2fd0b685ff9d7ec1/e00aa/wsgi.png 147w,\n/static/3abd686ff30f995d2fd0b685ff9d7ec1/e1902/wsgi.png 295w,\n/static/3abd686ff30f995d2fd0b685ff9d7ec1/3befa/wsgi.png 589w","sizes":"(min-width: 589px) 589px, 100vw"},"sources":[{"srcSet":"/static/3abd686ff30f995d2fd0b685ff9d7ec1/f92c2/wsgi.webp 147w,\n/static/3abd686ff30f995d2fd0b685ff9d7ec1/dfd91/wsgi.webp 295w,\n/static/3abd686ff30f995d2fd0b685ff9d7ec1/9dc86/wsgi.webp 589w","type":"image/webp","sizes":"(min-width: 589px) 589px, 100vw"}]},"width":589,"height":371}}}}}},"pageContext":{"id":"475be942-afef-5df2-b64f-48ee8916da26","frontmatter__slug":"/blog/revisit-wsgi/","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":[]}