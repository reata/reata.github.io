{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-js","path":"/blog/sqllineage-a-sql-lineage-analysis-tool/","result":{"data":{"markdownRemark":{"html":"<h2>缘起</h2>\n<p>做数据的人，都离不开宿命的SQL。从Hive到Spark SQL，SQL形式的ETL已经覆盖了大数据离线计算的绝大多数场景。而Presto甚至提出了SQL on everything\n的口号，旨在做一个针对异构系统的统一操作引擎，查询语言毫无疑问是SQL。而随着Flink的普及，我们也开始看到SQL进入流式计算的领域。无处不在的SQL，\nSQL可能会比我们活得都长。但即便如此，这些依然改变不了SQL本身层次多、冗余、难读的特点。</p>\n<p>我经常听数据仓库工程师说，分析人员抛过来了一个上千行、业务价值满满、同时也令人绝望的SQL。梳理清楚哪些表之间在做Join，结果又写进了哪张表，\n就需要花很长的时间，更不要说深入到其中的业务逻辑。从数据平台的角度，SQL血缘也有非常广泛的用途，首当其冲自然是构建表之间的数据血缘关系，\n数据血缘可以帮助开发人员更好地认识表之间的数据流向，理解业务，并且在需要做数据变更时去做影响分析。而在任务调度时，也可以通过表级别的血缘关系，\n反过来去推荐、诊断、优化任务级别依赖关系的配置。</p>\n<p>需求始终存在，但当年的我，不懂编译器（compiler）、语法分析（parser）、词法分析（lexical analyzer）等等概念，我试图用正则表达式（regular expression）\n这个朴素的手段来解决问题，想法也非常直接，FROM或者JOIN后面就是源表，INSERT INTO/INSERT OVERWRITE TABLE后面就是目标表嘛，easy，这个我稍微调试一下，\n两下就能写出来。</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 当年我用来抓取表名的正则</span>\nsource_table_regex <span class=\"token operator\">=</span> re<span class=\"token punctuation\">.</span><span class=\"token builtin\">compile</span><span class=\"token punctuation\">(</span><span class=\"token string\">r\"(?:from|join)\\s+(\\S*)(?:\\s+|;)\"</span><span class=\"token punctuation\">,</span> re<span class=\"token punctuation\">.</span>IGNORECASE<span class=\"token punctuation\">)</span>\ntarget_table_regex <span class=\"token operator\">=</span> re<span class=\"token punctuation\">.</span><span class=\"token builtin\">compile</span><span class=\"token punctuation\">(</span><span class=\"token string\">r\"insert\\s+(?:into|overwrite)\\s+table\\s+(\\S*)\\s+\"</span><span class=\"token punctuation\">,</span> re<span class=\"token punctuation\">.</span>IGNORECASE<span class=\"token punctuation\">)</span></code></pre></div>\n<p>这个方法显然不是这么准确，比如碰到下面这个SQL</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">insert</span> overwrite <span class=\"token keyword\">table</span> table_foo\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token comment\">/* let's play with a comment */</span> table_bar<span class=\"token punctuation\">;</span></code></pre></div>\n<p>显然我会认为/*是表名，虽然人家不过是个注释。</p>\n<p>再比如说我还可以写个恶趣味的SQL</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">select * from table_foo\nwhere description = \"from Excel\";</code></pre></div>\n<p>这时候Excel也变成一个表名了，确实很表，但它不是我想要的。</p>\n<p>虽然看起来确实很傻瓜、充满了漏洞，但这个正则的方案还是活了很久，事实上，加上一些if-else的判断和预处理，在生产环境中可能80%~90%的情况，\n它是可以返回正确结果的。不过，作为一个有追求的程序员，怎么可以满足于90分对吧。我也想借此机会了解一下编译原理相关的东西，\nAST抽象语法树这个东西我听的够多了，它到底是个啥呢？这些都一起促成了做<a href=\"https://github.com/reata/sqllineage\">SQLLineage</a>这个项目的初衷。</p>\n<p>（2022.3，作者按：学过编译原理之后回头看，词法分析器Lexer用的形式语言就是正则哦。）</p>\n<h2>设计思路</h2>\n<p>在动手开发之前，我先有过一些思考：</p>\n<p>我希望这个工具尽量简单，有命令行的界面，同时作为一个Python Package发布，这样pip安装后也可以import到其他的项目中。这个简单的工具，不会去执行SQL，\n或者连接任何元数据系统（比如Hive metastore）。我只对代码进行静态分析。优点当然是简单，而劣势就是可能这个血缘解析只能完美地做到表级别的血缘，\n对于字段级别的血缘，假如有select *的情况，就会丢失信息。这也是我暂时没有做字段级别血缘的主要原因。</p>\n<p>（2022.3，作者按：字段级别的血缘已经有初步的支持啦，请看<a href=\"/blog/sqllineage-towards-column-lineage/\">SQLLineage v1.3：迈向字段血缘</a>）</p>\n<p>另外一个取舍是从原理层面来说，我不想自己去做parser，最理想的情况是有一个通用的parser，可以将绝大多数常见的SQL方言解析成AST，\n然后我只要对AST进行分析，产出源表、目标表等人类可读的结果就好。遵循这个思路，我找到了<a href=\"https://github.com/andialbrecht/sqlparse\">sqlparse</a>这个项目，\n它将自己定位为一个不进行语法校验的通用SQL parser，当然也是基于Python来开发的。</p>\n<p>在sqlparse把SQL语句解析成AST之后，我们要做的事情就和之前正则的时候大差不差了。对于源表，无非是找到FROM或者JOIN相关的Keyword，看它后面的\nToken是什么，如果是Comment或者Whitespace就继续往后看，如果是Identifier，取出它的name，如果是Subquery，则递归地再搜索一层。当然如前面所说，\nsqlparse不进行语法校验，一方面这意味着有了更多SQL方言支持的可能，当然反过来，解析出来的结果可能是不对的。比如Subquery，在没写alias的情况下\n（在某些SQL方言中，子查询不写别名，语法也是正确），会被解析成了Identifier，不能直接取name。真正开始写代码之后，我发现各种各样的边界条件都是可能存在的。</p>\n<p>所以最开始在我的设想中，这个package就需要充分的测试，尽可能广的测试用例，尽可能高的测试覆盖。我是用pytest框架来做单元测试的，目前1.0版本总共有77个\n测试用例，代码覆盖率是97%，可以在<a href=\"https://codecov.io/gh/reata/sqllineage\">codecov</a>看到详尽的代码覆盖情况。</p>\n<h2>Show Me The Code</h2>\n<p>sqllineage已经发布到了PyPI上，可以通过pip直接进行安装使用：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ pip <span class=\"token function\">install</span> sqllineage\n<span class=\"token comment\"># 安装完成之后，会自带一个sqllineage的命令行工具</span>\n$ sqllineage -e <span class=\"token string\">\"insert into db1.table1 select * from db2.table2\"</span>\nStatements<span class=\"token punctuation\">(</span><span class=\"token comment\">#): 1</span>\nSource Tables:\n    db2.table2\nTarget Tables:\n    db1.table1</code></pre></div>\n<p>安装后也可以在Python脚本中直接调用：</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> sqllineage<span class=\"token punctuation\">.</span>runner <span class=\"token keyword\">import</span> LineageRunner\nsql <span class=\"token operator\">=</span> <span class=\"token triple-quoted-string string\">\"\"\"insert into db1.table11 select * from db2.table21 union select * from db2.table22; \ninsert into db3.table3 select * from db1.table11 join db1.table12;\"\"\"</span>\nresult <span class=\"token operator\">=</span> LineageRunner<span class=\"token punctuation\">(</span>sql<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 打印result，会产出下面的信息</span>\n<span class=\"token comment\"># Statements(#): 2</span>\n<span class=\"token comment\"># Source Tables:</span>\n<span class=\"token comment\">#    db1.table12</span>\n<span class=\"token comment\">#    db2.table21</span>\n<span class=\"token comment\">#    db2.table22</span>\n<span class=\"token comment\">#Target Tables:</span>\n<span class=\"token comment\">#    db3.table3</span>\n<span class=\"token comment\">#Intermediate Tables:</span>\n<span class=\"token comment\">#    db1.table11</span>\n\n<span class=\"token comment\"># 也可以直接获取各个源表</span>\n<span class=\"token keyword\">for</span> tbl <span class=\"token keyword\">in</span> result<span class=\"token punctuation\">.</span>source_tables<span class=\"token punctuation\">:</span> \n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>tbl<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">#db1.table12</span>\n<span class=\"token comment\">#db2.table21</span>\n<span class=\"token comment\">#db2.table22</span>\n\n<span class=\"token comment\"># 目标表当然也是可以的</span>\n<span class=\"token keyword\">for</span> tbl <span class=\"token keyword\">in</span> result<span class=\"token punctuation\">.</span>target_tables<span class=\"token punctuation\">:</span> \n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>tbl<span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># db3.table13</span>\n\n<span class=\"token comment\"># 甚至还可以调用matplotlib绘制血缘图</span>\nresult<span class=\"token punctuation\">.</span>draw<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>下面这样一张表级血缘图会自动弹出：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 740px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/922db8c46ba1a274138f9ae79f350e8a/94829/sqllineage.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.75675675675676%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAA9hAAAPYQGoP6dpAAAAxklEQVQoz4WS2w6EIAxE/f9v3aygqFBaZgMuXrDqQ0Og7WGm0AFASmmLuj+uLIJPb2HtsJ1B6cnR3QHbfZRUwJEFIrKDm/rumNDUafkK5gxv8kXh5Am9sfDe17bTra3iFu4p4js4OOdWIDFjXjwCUSnQGltgheXI/T4QiOhqWSQVO9qsrvmr6u5JgfwVFEvGwhj76uAdyCtwDhHCfDuGuiqW5dHyDoL6C4rCrGB0ExYf1LloL93WnIBLIAyjK698922eIEfgD+bsaHYIg1dKAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"sqllineage\"\n        title=\"sqllineage\"\n        src=\"/static/922db8c46ba1a274138f9ae79f350e8a/50383/sqllineage.png\"\n        srcset=\"/static/922db8c46ba1a274138f9ae79f350e8a/1d79a/sqllineage.png 185w,\n/static/922db8c46ba1a274138f9ae79f350e8a/1efb2/sqllineage.png 370w,\n/static/922db8c46ba1a274138f9ae79f350e8a/50383/sqllineage.png 740w,\n/static/922db8c46ba1a274138f9ae79f350e8a/94829/sqllineage.png 878w\"\n        sizes=\"(max-width: 740px) 100vw, 740px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>SQLLineage目前已经发布v1.0版本，进入稳定可用状态，让我一起来探索SQL血缘吧！</p>\n<p>（2022.3，作者按：从v1.2.2版本起，SQLLineage可以部署为一个Web App，欢迎访问这个<a href=\"https://reata.github.io/sqllineage/\">DEMO</a>）</p>\n<h2>相关链接</h2>\n<ul>\n<li>代码：<a href=\"https://github.com/reata/sqllineage\">https://github.com/reata/sqllineage</a></li>\n<li>文档：<a href=\"https://sqllineage.readthedocs.io/\">https://sqllineage.readthedocs.io/</a></li>\n<li>PyPI：<a href=\"https://pypi.org/project/sqllineage/\">https://pypi.org/project/sqllineage/</a></li>\n</ul>","rawMarkdownBody":"\n## 缘起\n\n做数据的人，都离不开宿命的SQL。从Hive到Spark SQL，SQL形式的ETL已经覆盖了大数据离线计算的绝大多数场景。而Presto甚至提出了SQL on everything\n的口号，旨在做一个针对异构系统的统一操作引擎，查询语言毫无疑问是SQL。而随着Flink的普及，我们也开始看到SQL进入流式计算的领域。无处不在的SQL，\nSQL可能会比我们活得都长。但即便如此，这些依然改变不了SQL本身层次多、冗余、难读的特点。\n\n我经常听数据仓库工程师说，分析人员抛过来了一个上千行、业务价值满满、同时也令人绝望的SQL。梳理清楚哪些表之间在做Join，结果又写进了哪张表，\n就需要花很长的时间，更不要说深入到其中的业务逻辑。从数据平台的角度，SQL血缘也有非常广泛的用途，首当其冲自然是构建表之间的数据血缘关系，\n数据血缘可以帮助开发人员更好地认识表之间的数据流向，理解业务，并且在需要做数据变更时去做影响分析。而在任务调度时，也可以通过表级别的血缘关系，\n反过来去推荐、诊断、优化任务级别依赖关系的配置。\n\n需求始终存在，但当年的我，不懂编译器（compiler）、语法分析（parser）、词法分析（lexical analyzer）等等概念，我试图用正则表达式（regular expression）\n这个朴素的手段来解决问题，想法也非常直接，FROM或者JOIN后面就是源表，INSERT INTO/INSERT OVERWRITE TABLE后面就是目标表嘛，easy，这个我稍微调试一下，\n两下就能写出来。\n\n```python\n# 当年我用来抓取表名的正则\nsource_table_regex = re.compile(r\"(?:from|join)\\s+(\\S*)(?:\\s+|;)\", re.IGNORECASE)\ntarget_table_regex = re.compile(r\"insert\\s+(?:into|overwrite)\\s+table\\s+(\\S*)\\s+\", re.IGNORECASE)\n```\n\n这个方法显然不是这么准确，比如碰到下面这个SQL\n\n```sql\ninsert overwrite table table_foo\nselect * from /* let's play with a comment */ table_bar;\n```\n\n显然我会认为/*是表名，虽然人家不过是个注释。\n\n再比如说我还可以写个恶趣味的SQL\n\n```\nselect * from table_foo\nwhere description = \"from Excel\";\n```\n\n这时候Excel也变成一个表名了，确实很表，但它不是我想要的。\n\n虽然看起来确实很傻瓜、充满了漏洞，但这个正则的方案还是活了很久，事实上，加上一些if-else的判断和预处理，在生产环境中可能80%~90%的情况，\n它是可以返回正确结果的。不过，作为一个有追求的程序员，怎么可以满足于90分对吧。我也想借此机会了解一下编译原理相关的东西，\nAST抽象语法树这个东西我听的够多了，它到底是个啥呢？这些都一起促成了做[SQLLineage](https://github.com/reata/sqllineage)这个项目的初衷。\n\n（2022.3，作者按：学过编译原理之后回头看，词法分析器Lexer用的形式语言就是正则哦。）\n\n## 设计思路\n\n在动手开发之前，我先有过一些思考：\n\n我希望这个工具尽量简单，有命令行的界面，同时作为一个Python Package发布，这样pip安装后也可以import到其他的项目中。这个简单的工具，不会去执行SQL，\n或者连接任何元数据系统（比如Hive metastore）。我只对代码进行静态分析。优点当然是简单，而劣势就是可能这个血缘解析只能完美地做到表级别的血缘，\n对于字段级别的血缘，假如有select *的情况，就会丢失信息。这也是我暂时没有做字段级别血缘的主要原因。\n\n（2022.3，作者按：字段级别的血缘已经有初步的支持啦，请看[SQLLineage v1.3：迈向字段血缘](/blog/sqllineage-towards-column-lineage/)）\n\n另外一个取舍是从原理层面来说，我不想自己去做parser，最理想的情况是有一个通用的parser，可以将绝大多数常见的SQL方言解析成AST，\n然后我只要对AST进行分析，产出源表、目标表等人类可读的结果就好。遵循这个思路，我找到了[sqlparse](https://github.com/andialbrecht/sqlparse)这个项目，\n它将自己定位为一个不进行语法校验的通用SQL parser，当然也是基于Python来开发的。\n\n在sqlparse把SQL语句解析成AST之后，我们要做的事情就和之前正则的时候大差不差了。对于源表，无非是找到FROM或者JOIN相关的Keyword，看它后面的\nToken是什么，如果是Comment或者Whitespace就继续往后看，如果是Identifier，取出它的name，如果是Subquery，则递归地再搜索一层。当然如前面所说，\nsqlparse不进行语法校验，一方面这意味着有了更多SQL方言支持的可能，当然反过来，解析出来的结果可能是不对的。比如Subquery，在没写alias的情况下\n（在某些SQL方言中，子查询不写别名，语法也是正确），会被解析成了Identifier，不能直接取name。真正开始写代码之后，我发现各种各样的边界条件都是可能存在的。\n\n所以最开始在我的设想中，这个package就需要充分的测试，尽可能广的测试用例，尽可能高的测试覆盖。我是用pytest框架来做单元测试的，目前1.0版本总共有77个\n测试用例，代码覆盖率是97%，可以在[codecov](https://codecov.io/gh/reata/sqllineage)看到详尽的代码覆盖情况。\n\n## Show Me The Code\n\nsqllineage已经发布到了PyPI上，可以通过pip直接进行安装使用：\n```bash\n$ pip install sqllineage\n# 安装完成之后，会自带一个sqllineage的命令行工具\n$ sqllineage -e \"insert into db1.table1 select * from db2.table2\"\nStatements(#): 1\nSource Tables:\n    db2.table2\nTarget Tables:\n    db1.table1\n```\n\n安装后也可以在Python脚本中直接调用：\n```python\nfrom sqllineage.runner import LineageRunner\nsql = \"\"\"insert into db1.table11 select * from db2.table21 union select * from db2.table22; \ninsert into db3.table3 select * from db1.table11 join db1.table12;\"\"\"\nresult = LineageRunner(sql)\nprint(result)\n# 打印result，会产出下面的信息\n# Statements(#): 2\n# Source Tables:\n#    db1.table12\n#    db2.table21\n#    db2.table22\n#Target Tables:\n#    db3.table3\n#Intermediate Tables:\n#    db1.table11\n\n# 也可以直接获取各个源表\nfor tbl in result.source_tables: \n    print(tbl)\n#db1.table12\n#db2.table21\n#db2.table22\n\n# 目标表当然也是可以的\nfor tbl in result.target_tables: \n    print(tbl)\n# db3.table13\n\n# 甚至还可以调用matplotlib绘制血缘图\nresult.draw()\n```\n下面这样一张表级血缘图会自动弹出：\n\n![sqllineage](../images/sqllineage.png)\n\n\nSQLLineage目前已经发布v1.0版本，进入稳定可用状态，让我一起来探索SQL血缘吧！\n\n（2022.3，作者按：从v1.2.2版本起，SQLLineage可以部署为一个Web App，欢迎访问这个[DEMO](https://reata.github.io/sqllineage/)）\n\n\n## 相关链接\n- 代码：[https://github.com/reata/sqllineage](https://github.com/reata/sqllineage)\n- 文档：[https://sqllineage.readthedocs.io/](https://sqllineage.readthedocs.io/)\n- PyPI：[https://pypi.org/project/sqllineage/](https://pypi.org/project/sqllineage/)\n","frontmatter":{"date":"September 20, 2020","slug":"/blog/sqllineage-a-sql-lineage-analysis-tool/","title":"SQLLineage: 基于Python的SQL血缘分析工具","excerpt":"构建表级血缘","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/e29ed1737d1b33312665d4f1739cee79/f6810/dag.jpg","srcSet":"/static/e29ed1737d1b33312665d4f1739cee79/eee8e/dag.jpg 400w,\n/static/e29ed1737d1b33312665d4f1739cee79/1e21a/dag.jpg 800w,\n/static/e29ed1737d1b33312665d4f1739cee79/f6810/dag.jpg 1600w","sizes":"(min-width: 1600px) 1600px, 100vw"},"sources":[{"srcSet":"/static/e29ed1737d1b33312665d4f1739cee79/dff21/dag.webp 400w,\n/static/e29ed1737d1b33312665d4f1739cee79/b2a35/dag.webp 800w,\n/static/e29ed1737d1b33312665d4f1739cee79/e9d78/dag.webp 1600w","type":"image/webp","sizes":"(min-width: 1600px) 1600px, 100vw"}]},"width":1600,"height":900}}}}}},"pageContext":{"id":"11d6b879-9c65-5d33-880a-c81db22eb351","frontmatter__slug":"/blog/sqllineage-a-sql-lineage-analysis-tool/","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":[]}