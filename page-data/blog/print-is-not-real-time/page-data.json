{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-js","path":"/blog/print-is-not-real-time/","result":{"data":{"markdownRemark":{"html":"<p>最近遇到了一个奇异的现象，我有一段Python脚本，执行过程中每隔若干时间，会打印一段日志到标准输出。脚本是通过另一个平台托管执行的，平台以子进程的形式启动Python脚本，并且会捕获子进程的标准输出，将其重定向到平台提供的日志文件。</p>\n<p>Python脚本很简单，类似下面这样：</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> time\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    time<span class=\"token punctuation\">.</span>sleep<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>对于上面这段代码，理论上应该是每隔1秒，就会打印一行日志。当我在命令行中直接执行这个脚本时，结果正如我们所料。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">python test.py</code></pre></div>\n<p>但当这个脚本在平台上执行，我去观察日志文件时，却发现，日志不会实时打印。正相反，所有日志内容都是在10秒过后，一次性出现在日志文件中：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">tail</span> <span class=\"token parameter variable\">-f</span> test.log</code></pre></div>\n<h2>平台的问题？</h2>\n<p>程序员的第一反应，肯定不是自己的锅。于是友好交流了一番，对方表示，平台上其他的bash和Java任务，输出到标准输出的内容，都是实时打印的。一直也有一些Python任务，但从来没有听说过这类问题。于是我分别测试了一下：</p>\n<p>Bash版本：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">seq</span> <span class=\"token number\">0</span> <span class=\"token number\">9</span><span class=\"token variable\">)</span></span>\n    <span class=\"token keyword\">do</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$i</span>\n    <span class=\"token function\">sleep</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">done</span></code></pre></div>\n<p>Java版本：</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">App</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>分别用如下命令，在该平台中执行，然后同样去tail日志文件。发现确实，这两段代码的日志是实时的。所以不存在平台启动子进程的时候，没有实时捕获子进程标准输出的问题。</p>\n<p>那么问题是出在Python身上了吗？</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sh</span> test.sh\n<span class=\"token function\">java</span> <span class=\"token parameter variable\">-jar</span> App.jar</code></pre></div>\n<h2>print的问题？</h2>\n<p>通常Python打印日志，是会用标准库里的logging模块来实现的。这里因为是平台托管明确表示将数据打印到标准输出即可，所以我就偷懒用了print。那么改回用logging来模拟同样的日志行为，结果会不会有不同呢？</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> logging\n<span class=\"token keyword\">import</span> sys\n<span class=\"token keyword\">import</span> time\n\nlogging<span class=\"token punctuation\">.</span>basicConfig<span class=\"token punctuation\">(</span>level<span class=\"token operator\">=</span>logging<span class=\"token punctuation\">.</span>DEBUG<span class=\"token punctuation\">,</span> stream<span class=\"token operator\">=</span>sys<span class=\"token punctuation\">.</span>stdout<span class=\"token punctuation\">,</span> <span class=\"token builtin\">format</span><span class=\"token operator\">=</span><span class=\"token string\">'%(message)s'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    logging<span class=\"token punctuation\">.</span>info<span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    time<span class=\"token punctuation\">.</span>sleep<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>这里我们降低了日志级别到DEBUG，以便INFO级别的信息可以打印出来。并且logging默认配置是打印到标准错误的，这里也改成了标准输出。执行后再去看日志文件中的信息，发现是实时打印出来的。换言之，切换到logging之后，平台可以捕获到我们脚本的标准输出了。</p>\n<p>print和logging，都是输出到stdout，区别在哪里呢？</p>\n<h2>logging</h2>\n<p>logging默认使用的是StreamHandler。</p>\n<p>logger完成<a href=\"https://github.com/python/cpython/blob/3.10/Lib/logging/__init__.py#L1622\">record的拼装</a>后，会调用自己的handle方法。handle方法最终会拿到logger对应的各个handler，并<a href=\"https://github.com/python/cpython/blob/3.10/Lib/logging/__init__.py#L1696\">调用handler的handle方法</a>。</p>\n<p>对于handler来说，其<a href=\"https://github.com/python/cpython/blob/3.10/Lib/logging/__init__.py#L955\">handle方法</a>统一写在父类Handler中，主要逻辑是过滤数据，获取锁，并emit相应的record。我们已经保证了打印的INFO级别，高于默认的DEBUG级别，日志不会被过滤掉。于是核心的逻辑，就在emit方法上了。Handle父类中的emit是个抽象方法，需要各个子类自行实现。我们来重点看一下StreamHandler子类的实现：</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">    <span class=\"token keyword\">def</span> <span class=\"token function\">flush</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        Flushes the stream.\n        \"\"\"</span>\n        self<span class=\"token punctuation\">.</span>acquire<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> self<span class=\"token punctuation\">.</span>stream <span class=\"token keyword\">and</span> <span class=\"token builtin\">hasattr</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>stream<span class=\"token punctuation\">,</span> <span class=\"token string\">\"flush\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                self<span class=\"token punctuation\">.</span>stream<span class=\"token punctuation\">.</span>flush<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">finally</span><span class=\"token punctuation\">:</span>\n            self<span class=\"token punctuation\">.</span>release<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">emit</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> record<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span>\n            msg <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span><span class=\"token builtin\">format</span><span class=\"token punctuation\">(</span>record<span class=\"token punctuation\">)</span>\n            stream <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>stream\n            <span class=\"token comment\"># issue 35046: merged two stream.writes into one.</span>\n            stream<span class=\"token punctuation\">.</span>write<span class=\"token punctuation\">(</span>msg <span class=\"token operator\">+</span> self<span class=\"token punctuation\">.</span>terminator<span class=\"token punctuation\">)</span>\n            self<span class=\"token punctuation\">.</span>flush<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">except</span> RecursionError<span class=\"token punctuation\">:</span>  <span class=\"token comment\"># See issue 36272</span>\n            <span class=\"token keyword\">raise</span>\n        <span class=\"token keyword\">except</span> Exception<span class=\"token punctuation\">:</span>\n            self<span class=\"token punctuation\">.</span>handleError<span class=\"token punctuation\">(</span>record<span class=\"token punctuation\">)</span></code></pre></div>\n<p>这里的stream就是我们传入的sys.stdout。sys.stdout.write，和print没有什么本质的不同。区别在于flush方法。flush的作用，是将程序缓冲池中的内容，真正调用操作系统的IO接口，刷到对应的文件中。缓冲池的作用，是避免频繁调用操作系统接口，造成IO效率降低。</p>\n<p>看一下print函数的签名，果然，默认是不会flush的。</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">print</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> sep<span class=\"token operator\">=</span><span class=\"token string\">' '</span><span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">file</span><span class=\"token operator\">=</span><span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># known special case of print</span>\n    <span class=\"token triple-quoted-string string\">\"\"\"\n    print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n    \n    Prints the values to a stream, or to sys.stdout by default.\n    Optional keyword arguments:\n    file:  a file-like object (stream); defaults to the current sys.stdout.\n    sep:   string inserted between values, default a space.\n    end:   string appended after the last value, default a newline.\n    flush: whether to forcibly flush the stream.\n    \"\"\"</span>\n    <span class=\"token keyword\">pass</span></code></pre></div>\n<h2>print with flush</h2>\n<p>既然print函数中有flush这个参数，那么我们手动传参，是不是也可以达到logging的效果呢？</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> time\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>i，flush<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n    time<span class=\"token punctuation\">.</span>sleep<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>经过测试，果然，这样改写后，也可以达到实时写入日志的效果。</p>\n<h2>前台与后台</h2>\n<p>尽管logging和print with flush，都解决了实时打印日志的这个问题。但还有最后一个疑惑，为什么最初的脚本，在命令行中直接调用，是实时打印的。只有在平台里执行，才会暴露出需要flush的这个问题。</p>\n<p>我们可以在命令行中，模拟平台的操作：启动一个后台进程作为当前命令行进程的子进程，同时重定向标准输出到日志文件：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">python test.py <span class=\"token operator\">></span> test.log <span class=\"token operator\">&amp;</span>\n<span class=\"token function\">tail</span> <span class=\"token parameter variable\">-f</span> test.log</code></pre></div>\n<p>不加flush不用logging，当我们查看日志时，可以完全复现在平台中的行为：即仅当该Python进程完成，日志文件中才会一次出现所有内容。</p>\n<p>这个行为，记录在Python的<a href=\"https://docs.python.org/3/library/sys.html#sys.stdout\">官方文档</a>中：</p>\n<blockquote>\n<p>When interactive, the stdout stream is line-buffered. Otherwise, it is block-buffered like regular text > files. The stderr stream is line-buffered in both cases. You can make both streams unbuffered by passing > the -u command-line option or setting the PYTHONUNBUFFERED environment variable.</p>\n</blockquote>\n<p>这样就清楚了，在命令行中交互执行（前台执行）时，stdout是按行缓冲的。也就是说，每一行结束，都会自动flush。而当后台执行时，就和正常写文件一样，按块缓冲了。操作系统块肯定远大于我们打印的9个数字的长度，缓冲池没有满，日志自然不会被打印出来了。</p>\n<p>参照文档里描述的，我们通过增加-u选项：</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">python <span class=\"token operator\">-</span>u test<span class=\"token punctuation\">.</span>py <span class=\"token operator\">></span> test<span class=\"token punctuation\">.</span>log <span class=\"token operator\">&amp;</span>\ntail <span class=\"token operator\">-</span>f test<span class=\"token punctuation\">.</span>log</code></pre></div>\n<p>或者设置PYTHONUNBUFFERED环境变量：</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">PYTHONUNBUFFERED<span class=\"token operator\">=</span><span class=\"token number\">1</span> python test<span class=\"token punctuation\">.</span>py <span class=\"token operator\">></span> test<span class=\"token punctuation\">.</span>log <span class=\"token operator\">&amp;</span>\ntail <span class=\"token operator\">-</span>f test<span class=\"token punctuation\">.</span>log</code></pre></div>\n<p>二者都可以在没有flush的情况下，将日志实时打印出来。</p>","rawMarkdownBody":"\n最近遇到了一个奇异的现象，我有一段Python脚本，执行过程中每隔若干时间，会打印一段日志到标准输出。脚本是通过另一个平台托管执行的，平台以子进程的形式启动Python脚本，并且会捕获子进程的标准输出，将其重定向到平台提供的日志文件。\n\nPython脚本很简单，类似下面这样：\n\n```python\nimport time\nfor i in range(10):\n    print(i)\n    time.sleep(1)\n```\n\n对于上面这段代码，理论上应该是每隔1秒，就会打印一行日志。当我在命令行中直接执行这个脚本时，结果正如我们所料。\n\n```bash\npython test.py\n```\n\n但当这个脚本在平台上执行，我去观察日志文件时，却发现，日志不会实时打印。正相反，所有日志内容都是在10秒过后，一次性出现在日志文件中：\n\n```bash\ntail -f test.log\n```\n\n## 平台的问题？\n\n程序员的第一反应，肯定不是自己的锅。于是友好交流了一番，对方表示，平台上其他的bash和Java任务，输出到标准输出的内容，都是实时打印的。一直也有一些Python任务，但从来没有听说过这类问题。于是我分别测试了一下：\n\nBash版本：\n```bash\nfor i in $(seq 0 9)\n    do echo $i\n    sleep 1\ndone\n```\n\nJava版本：\n```java\npublic class App {\n    public static void main(String[] args) throws InterruptedException {\n        for (int i = 0; i < 10; i++) {\n            System.out.println(i);\n            Thread.sleep(1000);\n        }\n    }\n}\n```\n\n分别用如下命令，在该平台中执行，然后同样去tail日志文件。发现确实，这两段代码的日志是实时的。所以不存在平台启动子进程的时候，没有实时捕获子进程标准输出的问题。\n\n那么问题是出在Python身上了吗？\n```bash\nsh test.sh\njava -jar App.jar\n```\n\n## print的问题？\n\n通常Python打印日志，是会用标准库里的logging模块来实现的。这里因为是平台托管明确表示将数据打印到标准输出即可，所以我就偷懒用了print。那么改回用logging来模拟同样的日志行为，结果会不会有不同呢？\n\n```python\nimport logging\nimport sys\nimport time\n\nlogging.basicConfig(level=logging.DEBUG, stream=sys.stdout, format='%(message)s')\n\nfor i in range(10):\n    logging.info(i)\n    time.sleep(1)\n```\n\n这里我们降低了日志级别到DEBUG，以便INFO级别的信息可以打印出来。并且logging默认配置是打印到标准错误的，这里也改成了标准输出。执行后再去看日志文件中的信息，发现是实时打印出来的。换言之，切换到logging之后，平台可以捕获到我们脚本的标准输出了。\n\nprint和logging，都是输出到stdout，区别在哪里呢？\n\n\n## logging\n\nlogging默认使用的是StreamHandler。\n\nlogger完成[record的拼装](https://github.com/python/cpython/blob/3.10/Lib/logging/__init__.py#L1622)后，会调用自己的handle方法。handle方法最终会拿到logger对应的各个handler，并[调用handler的handle方法](https://github.com/python/cpython/blob/3.10/Lib/logging/__init__.py#L1696)。\n\n对于handler来说，其[handle方法](https://github.com/python/cpython/blob/3.10/Lib/logging/__init__.py#L955)统一写在父类Handler中，主要逻辑是过滤数据，获取锁，并emit相应的record。我们已经保证了打印的INFO级别，高于默认的DEBUG级别，日志不会被过滤掉。于是核心的逻辑，就在emit方法上了。Handle父类中的emit是个抽象方法，需要各个子类自行实现。我们来重点看一下StreamHandler子类的实现：\n\n```python\n    def flush(self):\n        \"\"\"\n        Flushes the stream.\n        \"\"\"\n        self.acquire()\n        try:\n            if self.stream and hasattr(self.stream, \"flush\"):\n                self.stream.flush()\n        finally:\n            self.release()\n\n    def emit(self, record):\n        try:\n            msg = self.format(record)\n            stream = self.stream\n            # issue 35046: merged two stream.writes into one.\n            stream.write(msg + self.terminator)\n            self.flush()\n        except RecursionError:  # See issue 36272\n            raise\n        except Exception:\n            self.handleError(record)\n```\n\n这里的stream就是我们传入的sys.stdout。sys.stdout.write，和print没有什么本质的不同。区别在于flush方法。flush的作用，是将程序缓冲池中的内容，真正调用操作系统的IO接口，刷到对应的文件中。缓冲池的作用，是避免频繁调用操作系统接口，造成IO效率降低。\n\n看一下print函数的签名，果然，默认是不会flush的。\n\n```python\ndef print(self, *args, sep=' ', end='\\n', file=None): # known special case of print\n    \"\"\"\n    print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n    \n    Prints the values to a stream, or to sys.stdout by default.\n    Optional keyword arguments:\n    file:  a file-like object (stream); defaults to the current sys.stdout.\n    sep:   string inserted between values, default a space.\n    end:   string appended after the last value, default a newline.\n    flush: whether to forcibly flush the stream.\n    \"\"\"\n    pass\n```\n\n## print with flush\n\n既然print函数中有flush这个参数，那么我们手动传参，是不是也可以达到logging的效果呢？\n\n```python\nimport time\nfor i in range(10):\n    print(i，flush=True)\n    time.sleep(1)\n```\n\n经过测试，果然，这样改写后，也可以达到实时写入日志的效果。\n\n## 前台与后台\n\n尽管logging和print with flush，都解决了实时打印日志的这个问题。但还有最后一个疑惑，为什么最初的脚本，在命令行中直接调用，是实时打印的。只有在平台里执行，才会暴露出需要flush的这个问题。\n\n我们可以在命令行中，模拟平台的操作：启动一个后台进程作为当前命令行进程的子进程，同时重定向标准输出到日志文件：\n\n```bash\npython test.py > test.log &\ntail -f test.log\n```\n\n不加flush不用logging，当我们查看日志时，可以完全复现在平台中的行为：即仅当该Python进程完成，日志文件中才会一次出现所有内容。\n\n这个行为，记录在Python的[官方文档](https://docs.python.org/3/library/sys.html#sys.stdout)中：\n\n> When interactive, the stdout stream is line-buffered. Otherwise, it is block-buffered like regular text > files. The stderr stream is line-buffered in both cases. You can make both streams unbuffered by passing > the -u command-line option or setting the PYTHONUNBUFFERED environment variable.\n\n这样就清楚了，在命令行中交互执行（前台执行）时，stdout是按行缓冲的。也就是说，每一行结束，都会自动flush。而当后台执行时，就和正常写文件一样，按块缓冲了。操作系统块肯定远大于我们打印的9个数字的长度，缓冲池没有满，日志自然不会被打印出来了。\n\n参照文档里描述的，我们通过增加-u选项：\n\n```python\npython -u test.py > test.log &\ntail -f test.log\n```\n\n或者设置PYTHONUNBUFFERED环境变量：\n\n```python\nPYTHONUNBUFFERED=1 python test.py > test.log &\ntail -f test.log\n```\n\n二者都可以在没有flush的情况下，将日志实时打印出来。\n","frontmatter":{"date":"October 23, 2022","slug":"/blog/print-is-not-real-time/","title":"print不会实时打印？","excerpt":"是什么阻挡了print","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/bb42d5122acce470c5e2645e5c19ff4e/f82ed/python-print.png","srcSet":"/static/bb42d5122acce470c5e2645e5c19ff4e/aa538/python-print.png 126w,\n/static/bb42d5122acce470c5e2645e5c19ff4e/38af9/python-print.png 252w,\n/static/bb42d5122acce470c5e2645e5c19ff4e/f82ed/python-print.png 504w","sizes":"(min-width: 504px) 504px, 100vw"},"sources":[{"srcSet":"/static/bb42d5122acce470c5e2645e5c19ff4e/84da1/python-print.webp 126w,\n/static/bb42d5122acce470c5e2645e5c19ff4e/5165c/python-print.webp 252w,\n/static/bb42d5122acce470c5e2645e5c19ff4e/92bed/python-print.webp 504w","type":"image/webp","sizes":"(min-width: 504px) 504px, 100vw"}]},"width":504,"height":236}}}}}},"pageContext":{"id":"104ca7d2-1d9a-573a-af13-74503dd548a9","frontmatter__slug":"/blog/print-is-not-real-time/","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":[]}